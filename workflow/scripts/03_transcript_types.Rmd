---
output: html_document
params:
  f_talon_data: 
    value: "~/../../Volumes/sevillas2-1/rbl3_final/05_talon/counts/SIRV_talon_abundance_filtered.tsv"
  u_talon_data: 
    value: "~/../../Volumes/sevillas2-1/rbl3_final/05_talon/counts/SIRV_talon_abundance.tsv"
  u_flair_data: 
    value: "~/../../Volumes/sevillas2-1/rbl3_final/06_flair/counts/flair_counts_matrix.tsv"
  output_dir:
    value: "~/../../Volumes/sevillas2-1/rbl3_final/07_report"
  log_dir:
    value: "~/../../Volumes/sevillas2-1/rbl3_final/log"
  perc_sim:
    value: 20
  num_match:
    value: 5
  ref_masking:
    value: FALSE
  clean_up:
    value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(tidyverse)
library(ggpubr)
library(reshape2)
library(knitr)
library(stringr)

#references
#https://www.biorxiv.org/content/10.1101/672931v2.supplementary-material
```

```{r Params, echo=FALSE}
talon_filtered_data = params$f_talon_data
talon_unfiltered_data = params$u_talon_data
flair_data = params$u_flair_data
out_dir = params$output_dir
```

# Analysis Workflow
For complete workflow documentation, review the [Wiki](https://github.com/RBL-NCI/RBL_RBL3/wiki/Overview) page for the pipeline. This pipeline included parameters:

- reference masking: ``r params$ref_masking``

- transcript cleanup performed: ``r params$clean_up``

Both parameters will impact the results below. For more detailed information on the parameters, review the snakemake_config.yaml file within the ``r params$log_dir`` directory.


```{r, echo=FALSE}
#plot transcript read lengths, read counts, exon counts
TranscriptFeatures <- function(df_in,title_in,type_in) {
  abund_df = read.csv(df_in,sep="\t")
  
  p1 = ggplot(abund_df, aes(x=transcript_novelty, y=length, fill=transcript_novelty)) + 
    geom_violin(trim=FALSE)+
    geom_boxplot(width=0.1, fill="white")+
    labs(title="Plot of read length \n\n",
         x="Transcript type", y = "Read Length")+
    scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(trans = 'log10')
  
  p2 = ggplot(abund_df, aes(x=transcript_novelty, y=n_exons, fill=transcript_novelty)) + 
    geom_violin(trim=FALSE)+
    geom_boxplot(width=0.1, fill="white")+
    labs(title="Plot of number of exons \n\n",
         x="Transcript Type", y = "Number of Exons") +
    scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(trans = 'log10')

  #aggregate by type
  transcript_nov = aggregate(get(colnames(abund_df[12]))~transcript_novelty,abund_df,sum)
  colnames(transcript_nov)[2] <- colnames(abund_df[12])
  
  for (i in range(13:ncol(abund_df))){
    transcript_nov[,colnames(abund_df[i])] = aggregate(get(colnames(abund_df[i]))
                                                           ~transcript_novelty,abund_df,sum)[2]
    
  }                      
  
  #melt and plot
  dfm <- melt(transcript_nov[,c('transcript_novelty',
                                colnames(abund_df)[12:ncol(abund_df)])],
              id.vars = 1)

  p3 = ggplot(dfm,aes(x = transcript_novelty,y = value)) + 
      geom_bar(aes(fill = variable),stat = "identity",position = "dodge") + 
    labs(y="Read Counts", fill = "sample_id") + 
    ggtitle("Plot of read counts \n\n") +
    scale_fill_brewer(palette="Dark2") + theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(trans = 'log10') 

  p4 = ggparagraph(
    paste0("\n\n\n",title_in),
    color = NULL,
    size = 20,
    face = "bold",
    family = NULL,
    lineheight = NULL
  )
  
  #plot
  p_final = ggarrange(p1, p2, p3, p4,
            labels = c("A", "B", "C"),
            ncol = 2, nrow = 2)
    
  print(p_final)
  
  #save plot
  ggsave(paste0(out_dir,"/",type_in,".png"),p_final)
} 
```

## Transcript Type
### Talon data
 **TALON identified transcripts are summarized prior to filtering by type, with the following key:**

* ISM: incomplete splice match

* NIC: novel in catalog

* NNC: novel not in catalog

Two files are generated, including:

* A counts matrix was created, located at ```r talon_unfiltered_data```, which is previewed below:
```{r, echo=FALSE, message=FALSE}
#text files
talon_df = read.csv(talon_unfiltered_data,sep="\t")
kable(head(talon_df))
```

* A transcript summary was generated from this unfiltered data, log10 transformed:
```{r, echo=FALSE, message=FALSE}
#png files
TranscriptFeatures(talon_unfiltered_data,"    Unfiltered Data","unfiltered_abundance")
```

 **TALON identified transcripts are then filtered based on the following criteria**

1. transcripts are known OR

2. reads must have <``r params$perc_sim``% A in the 20bp interval after alignment AND be detected at least ``r params$num_match`` times in both replicates

Two files are generated, including:

* A counts matrix was created, located at ```r talon_filtered_data```, which is previewed below:
```{r, echo=FALSE, message=FALSE, warning=FALSE}
#text files
talon_df = read.csv(talon_filtered_data,sep="\t")
kable(head(talon_df))
```

* A transcript summary was generated from this filtered data, log10 transformed:
```{r, echo=FALSE, message=FALSE, warning=FALSE}
TranscriptFeatures(talon_filtered_data,"     Filtered Data","filtered_abundance")
```

### Flair data
 **Flair identified transcripts are summarized prior to DEG:**
 
Two files are generated, including:

* A counts matrix was created, located at ```r flair_data```, which is previewed below:
```{r, echo=FALSE, message=FALSE, warning=FALSE}
#text files
flair_df = read.csv(flair_data,sep="\t")
i=2
for (colid in colnames(flair_df)[2:ncol(flair_df)]){
  colnames(flair_df)[i] <- str_split(colid, "_")[[1]][[1]]
  i= i+1
}
kable(head(flair_df))
```

